# 服务依赖注入模式

本文档描述了团队报名系统服务端项目中使用的依赖注入模式，包括基础服务类的设计、领域服务的实现方式以及控制器层的最佳实践。

## BaseService 设计

`BaseService` 是所有领域服务的基类，提供了通用功能和依赖解析能力。它实现了以下核心功能：

1. **依赖解析**：通过容器自动解析所需的依赖项
2. **日志记录**：集成统一的日志记录功能
3. **错误处理**：标准化的错误处理流程
4. **事件发布**：简化的事件发布接口

详细实现请参考 `src/domains/BaseService.js`。

## 当前实现状态

目前，项目使用的依赖注入机制已实现：

1. **基础设施层**：通过 `src/infrastructure/index.js` 注册所有基础组件到依赖注入容器
2. **账户领域服务**：继承 `BaseService` 并通过容器解析依赖
3. **服务单例模式**：每个领域服务使用单例模式导出，确保全局状态一致性

## 最佳实践和注意事项

1. **保持领域边界**：领域服务应该尽量只依赖于自己领域内的组件和模型，跨领域的引用应通过依赖注入容器获取。

2. **延迟初始化**：对于一些重的依赖，应该在实际需要时才进行初始化，而不是在构造函数中就创建所有依赖。

3. **明确服务职责**：每个服务应该有明确的职责边界，避免创建"上帝服务"（God Service）。

4. **避免循环依赖**：设计服务之间的依赖关系时，应避免形成循环依赖，可以通过引入中间服务或事件机制解决。

5. **保持BaseService简单**：基础服务类应该只包含真正通用的功能，避免过度设计。

## 控制器层最佳实践

控制器作为应用层的组件，和领域服务的设计模式有所不同。以下是控制器层的一些最佳实践：

1. **一次性解析依赖**：在控制器文件顶部一次性解析常用的依赖，而不是在每个方法中重复调用`container.resolve()`：

   ```javascript
   // 文件顶部一次性解析常用依赖
   const logger = container.resolve('logger');
   const responseFormatter = container.resolve('responseFormatter');
   ```

2. **保持控制器轻量**：控制器应该主要负责：
   - 处理HTTP请求和响应
   - 调用领域服务
   - 格式化响应结果
   
   复杂的业务逻辑应当放在领域服务中实现。

3. **统一的响应格式**：使用统一的响应格式化器，保持API响应的一致性：

   ```javascript
   // 成功响应
   return responseFormatter.success(res, data, '操作成功');
   
   // 错误响应
   return responseFormatter.error(res, '操作失败');
   ```

4. **统一的错误处理**：在控制器中应该包含完善的错误处理，并记录日志：

   ```javascript
   try {
     // 业务逻辑
   } catch (error) {
     logger.error(`操作失败: ${error.message}`);
     return responseFormatter.error(res, '操作失败');
   }
   ```

## 依赖注入与路由加载

当前项目使用了自动化的路由加载机制，结合依赖注入实现：

1. **RouteLoader**: 自动搜索和加载定义在各领域中的 `routes.js` 文件
2. **路由定义**: 各领域的路由文件使用统一格式，导出路由配置

```javascript
// src/domains/account/routes.js 示例
const express = require('express');
const router = express.Router();
const container = require('../../infrastructure').container;

// 从容器中获取控制器或中间件
const authMiddleware = container.resolve('authMiddleware');
const accountController = container.resolve('accountController');

// 定义路由
router.post('/login', accountController.login);
router.get('/profile', authMiddleware, accountController.getProfile);

module.exports = router;
```

通过这些实践，我们可以使控制器代码更加简洁、一致，并且易于维护。控制器和服务层的职责边界更加清晰，控制器专注于HTTP请求处理，服务层专注于业务逻辑实现。 