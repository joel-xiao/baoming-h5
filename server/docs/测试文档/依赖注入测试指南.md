# 依赖注入模式测试指南

## 概述

本文档提供使用依赖注入模式的服务测试指南，详细说明如何对继承自 `BaseService` 的领域服务进行有效的单元测试和集成测试。

## 更新记录

**2023年4月6日更新**:
- 添加了 BaseService 单例模式测试方法
- 更新了依赖注入容器初始化顺序的测试用例
- 添加了服务预热机制测试指南
- 补充了跨领域服务引用的测试示例

## 测试环境搭建

### 单元测试依赖

```bash
npm install --save-dev jest sinon sinon-chai chai
```

### Jest 配置

```javascript
// jest.config.js
module.exports = {
  testEnvironment: 'node',
  coverageDirectory: 'coverage',
  collectCoverageFrom: [
    'src/domains/**/*.js',
    '!src/domains/**/routes.js',
    '!src/domains/index.js'
  ],
  moduleNameMapper: {
    '^@domains/(.*)$': '<rootDir>/src/domains/$1',
    '^@common/(.*)$': '<rootDir>/src/infrastructure/common/$1',
    '^@config/(.*)$': '<rootDir>/src/config/$1'
  }
};
```

## 领域服务测试技术

### 单元测试策略

对于领域服务的单元测试，我们采用以下策略：

1. **模拟依赖注入容器**：替换真实容器，返回模拟对象
2. **继承测试**：验证服务正确继承 `BaseService` 并调用其方法
3. **业务逻辑测试**：验证服务的核心业务逻辑
4. **错误处理测试**：验证服务在各种错误情况下的行为

### 模拟容器设置

```javascript
// __mocks__/containerMock.js
const sinon = require('sinon');

// 创建模拟依赖
const mockLogger = {
  info: sinon.stub(),
  error: sinon.stub(),
  warn: sinon.stub()
};

const mockEmailService = {
  sendEmail: sinon.stub().resolves({ success: true })
};

const mockIdGenerator = {
  generateRegistrationOrderId: sinon.stub().returns('REG-12345'),
  generateTeamOrderId: sinon.stub().returns('TEAM-12345'),
  generatePaymentOrderId: sinon.stub().returns('PAY-12345'),
  generateInviteCode: sinon.stub().returns('INV-12345'),
  generateUniqueId: sinon.stub().returns('ID-12345')
};

// 创建模拟容器
const mockContainer = {
  resolve: (name) => {
    switch(name) {
      case 'logger':
        return mockLogger;
      case 'emailService':
        return mockEmailService;
      case 'idGenerator':
        return mockIdGenerator;
      default:
        throw new Error(`依赖 ${name} 未找到`);
    }
  }
};

module.exports = {
  container: mockContainer,
  mockLogger,
  mockEmailService,
  mockIdGenerator
};
```

### 模拟特定领域依赖

```javascript
// __mocks__/modelFactoryMock.js
const sinon = require('sinon');

const createMockModelFactory = (mockRepository) => {
  return {
    getModel: sinon.stub().returns({}),
    getRepository: sinon.stub().returns(mockRepository)
  };
};

module.exports = createMockModelFactory;
```

## 测试示例

### 基础服务测试

```javascript
// domains/services/BaseService.test.js
const { expect } = require('chai');
const sinon = require('sinon');
const proxyquire = require('proxyquire');

// 导入模拟模块
const { 
  container,
  mockLogger, 
  mockEmailService,
  mockIdGenerator 
} = require('../../__mocks__/containerMock');

// 使用代理导入BaseService，注入模拟容器
const BaseService = proxyquire('../../../src/domains/services/BaseService', {
  '@common/di/Container': container
});

describe('BaseService', () => {
  let baseService;
  
  beforeEach(() => {
    // 重置所有模拟
    sinon.resetHistory();
    
    // 创建测试实例
    baseService = new BaseService();
  });
  
  describe('constructor', () => {
    it('should initialize common dependencies', () => {
      expect(baseService.logger).to.equal(mockLogger);
      expect(baseService.emailService).to.equal(mockEmailService);
      expect(baseService.idGenerator).to.equal(mockIdGenerator);
    });
  });
  
  describe('logInfo', () => {
    it('should call logger.info with correct message', () => {
      const message = 'Test info message';
      
      baseService.logInfo(message);
      
      expect(mockLogger.info.calledOnce).to.be.true;
      expect(mockLogger.info.calledWith(message)).to.be.true;
    });
  });
  
  describe('logError', () => {
    it('should call logger.error with formatted message', () => {
      const message = 'Test error';
      const error = new Error('Something went wrong');
      
      baseService.logError(message, error);
      
      expect(mockLogger.error.calledOnce).to.be.true;
      expect(mockLogger.error.calledWith(`${message}: ${error.message}`)).to.be.true;
    });
  });
  
  describe('sendEmail', () => {
    it('should call emailService.sendEmail with mail options', async () => {
      const mailOptions = {
        to: 'test@example.com',
        subject: 'Test Subject',
        text: 'Test content'
      };
      
      await baseService.sendEmail(mailOptions);
      
      expect(mockEmailService.sendEmail.calledOnce).to.be.true;
      expect(mockEmailService.sendEmail.calledWith(mailOptions)).to.be.true;
      expect(mockLogger.info.calledWith(`邮件已发送: ${mailOptions.to}`)).to.be.true;
    });
    
    it('should handle email sending errors properly', async () => {
      const mailOptions = {
        to: 'test@example.com',
        subject: 'Test Subject'
      };
      
      const error = new Error('Failed to send email');
      mockEmailService.sendEmail.rejects(error);
      
      await baseService.sendEmail(mailOptions);
      
      expect(mockLogger.error.calledWith(`发送邮件失败: ${error.message}`)).to.be.true;
    });
  });
  
  // 其他方法测试...
});
```

### 领域服务测试

```javascript
// domains/registration/services/RegistrationService.test.js
const { expect } = require('chai');
const sinon = require('sinon');
const proxyquire = require('proxyquire');

// 导入模拟
const { container } = require('../../../__mocks__/containerMock');
const createMockModelFactory = require('../../../__mocks__/modelFactoryMock');

// 创建模拟仓储
const mockRepository = {
  create: sinon.stub(),
  findOne: sinon.stub(),
  find: sinon.stub(),
  update: sinon.stub(),
  delete: sinon.stub(),
  count: sinon.stub(),
  paginate: sinon.stub()
};

// 创建模拟模型工厂
const mockModelFactory = createMockModelFactory(mockRepository);

// 配置container模拟
container.resolve = (name) => {
  if (name === 'modelFactory') return mockModelFactory;
  return container.resolve(name); // 使用默认模拟
};

// 使用代理导入服务
const RegistrationService = proxyquire('../../../src/domains/registration/services/RegistrationService', {
  '@common/di/Container': container,
  // 模拟其他依赖...
});

describe('RegistrationService', () => {
  let registrationService;
  
  beforeEach(() => {
    // 重置所有模拟
    sinon.resetHistory();
    
    // 获取服务实例
    registrationService = RegistrationService;
  });
  
  describe('init', () => {
    it('should initialize model factory and registration model', () => {
      expect(registrationService.modelFactory).to.equal(mockModelFactory);
      expect(mockModelFactory.getModel.calledOnce).to.be.true;
    });
  });
  
  describe('createRegistration', () => {
    it('should create registration successfully', async () => {
      const registrationData = {
        teamName: '测试团队',
        leader: { name: '张三', phone: '13800000000' }
      };
      
      const createdRegistration = {
        _id: '123456',
        ...registrationData
      };
      
      mockRepository.create.resolves(createdRegistration);
      
      const result = await registrationService.createRegistration(registrationData);
      
      expect(mockRepository.create.calledOnce).to.be.true;
      expect(mockRepository.create.calledWith(registrationData)).to.be.true;
      expect(result).to.deep.equal(createdRegistration);
    });
    
    it('should handle error during registration creation', async () => {
      const registrationData = {
        teamName: '测试团队'
      };
      
      const error = new Error('数据库错误');
      mockRepository.create.rejects(error);
      
      try {
        await registrationService.createRegistration(registrationData);
        expect.fail('应该抛出异常');
      } catch (err) {
        expect(err).to.equal(error);
      }
    });
  });
  
  // 其他方法测试...
});
```

### 子领域服务测试

```javascript
// domains/registration/subdomains/team/services/TeamService.test.js
const { expect } = require('chai');
const sinon = require('sinon');
const proxyquire = require('proxyquire');

// 导入模拟
const { container } = require('../../../../../__mocks__/containerMock');

// 创建模拟注册服务
const mockRegistrationService = {
  findRegistrations: sinon.stub(),
  getRegistrationById: sinon.stub(),
  createRegistration: sinon.stub(),
  updateRegistration: sinon.stub()
};

// 使用代理导入服务
const TeamService = proxyquire('../../../src/domains/registration/subdomains/team/services/TeamService', {
  '@common/di/Container': container,
  '../../../services/RegistrationService': mockRegistrationService
});

describe('TeamService', () => {
  let teamService;
  
  beforeEach(() => {
    // 重置所有模拟
    sinon.resetHistory();
    
    // 获取服务实例
    teamService = TeamService;
  });
  
  describe('createTeamLeader', () => {
    it('should create team leader successfully', async () => {
      const teamData = {
        name: '张三',
        phone: '13800000000',
        email: 'test@example.com',
        teamName: '测试团队'
      };
      
      // 配置模拟行为
      mockRegistrationService.findRegistrations.resolves([]);
      
      const createdTeam = {
        _id: '123456',
        teamName: '测试团队',
        leader: {
          name: '张三',
          phone: '13800000000'
        },
        inviteCode: 'INV-12345'
      };
      
      mockRegistrationService.createRegistration.resolves(createdTeam);
      
      const result = await teamService.createTeamLeader(teamData);
      
      expect(mockRegistrationService.findRegistrations.calledOnce).to.be.true;
      expect(mockRegistrationService.createRegistration.calledOnce).to.be.true;
      expect(result.success).to.be.true;
      expect(result.data.id).to.equal(createdTeam._id);
      expect(result.data.teamName).to.equal(createdTeam.teamName);
      expect(result.data.inviteCode).to.equal(createdTeam.inviteCode);
    });
    
    it('should return error if leader phone already exists', async () => {
      const teamData = {
        name: '张三',
        phone: '13800000000',
        teamName: '测试团队'
      };
      
      // 配置模拟行为 - 返回已存在的注册
      mockRegistrationService.findRegistrations.resolves([{ _id: '123' }]);
      
      const result = await teamService.createTeamLeader(teamData);
      
      expect(mockRegistrationService.findRegistrations.calledOnce).to.be.true;
      expect(mockRegistrationService.createRegistration.notCalled).to.be.true;
      expect(result.success).to.be.false;
      expect(result.message).to.include('领队手机号已被注册');
    });
  });
  
  // 其他方法测试...
});
```

## 集成测试

### 数据库集成测试

对于需要与数据库交互的测试，使用内存数据库：

```javascript
// test/integration/registration.test.js
const { expect } = require('chai');
const { MongoMemoryServer } = require('mongodb-memory-server');
const mongoose = require('mongoose');

// 不模拟容器和服务，使用真实实现
const database = require('../../../src/infrastructure/data/connectors/DatabaseConnector');
const Registration = require('../../../src/domains/registration/models/Registration');
const RegistrationService = require('../../../src/domains/registration/services/RegistrationService');

describe('Registration Service Integration', () => {
  let mongoServer;
  
  before(async () => {
    // 启动内存MongoDB服务器
    mongoServer = await MongoMemoryServer.create();
    const uri = mongoServer.getUri();
    
    // 配置数据库连接
    process.env.MONGODB_URI = uri;
    process.env.DB_TYPE = 'mongodb';
    
    // 连接数据库
    await database.connect();
  });
  
  after(async () => {
    // 清理
    await mongoose.disconnect();
    await mongoServer.stop();
  });
  
  beforeEach(async () => {
    // 清空测试前的数据
    await mongoose.connection.dropDatabase();
  });
  
  describe('createRegistration', () => {
    it('should create registration in database', async () => {
      const registrationData = {
        teamName: '集成测试团队',
        leader: {
          name: '测试领队',
          phone: '13888888888',
          email: 'test@example.com'
        },
        orderNo: 'TEST-ORDER-001',
        status: 'pending'
      };
      
      // 使用实际服务创建注册
      const registration = await RegistrationService.createRegistration(registrationData);
      
      // 验证结果
      expect(registration).to.have.property('_id');
      expect(registration.teamName).to.equal(registrationData.teamName);
      expect(registration.leader.name).to.equal(registrationData.leader.name);
      expect(registration.leader.phone).to.equal(registrationData.leader.phone);
      
      // 验证数据库中的记录
      const savedRegistration = await RegistrationService.getRegistrationById(registration._id);
      expect(savedRegistration).to.exist;
      expect(savedRegistration.teamName).to.equal(registrationData.teamName);
    });
  });
  
  // 其他集成测试...
});
```

### API 集成测试

测试 API 路由和控制器：

```javascript
// test/integration/api.test.js
const request = require('supertest');
const { expect } = require('chai');
const { MongoMemoryServer } = require('mongodb-memory-server');
const mongoose = require('mongoose');

// 导入应用
const app = require('../../../src/app');
const database = require('../../../src/infrastructure/data/connectors/DatabaseConnector');

describe('API Integration Tests', () => {
  let mongoServer;
  
  before(async () => {
    // 启动内存MongoDB服务器
    mongoServer = await MongoMemoryServer.create();
    const uri = mongoServer.getUri();
    
    // 配置数据库连接
    process.env.MONGODB_URI = uri;
    process.env.DB_TYPE = 'mongodb';
    
    // 连接数据库
    await database.connect();
  });
  
  after(async () => {
    // 清理
    await mongoose.disconnect();
    await mongoServer.stop();
  });
  
  beforeEach(async () => {
    // 清空测试前的数据
    await mongoose.connection.dropDatabase();
  });
  
  describe('POST /api/registration/leader', () => {
    it('should create team leader registration', async () => {
      const teamData = {
        name: 'API测试领队',
        phone: '13700000000',
        teamName: 'API测试团队',
        email: 'api@test.com'
      };
      
      const response = await request(app)
        .post('/api/registration/leader')
        .send(teamData)
        .expect(201);
      
      expect(response.body.success).to.be.true;
      expect(response.body.message).to.equal('团队创建成功');
      expect(response.body.data).to.have.property('id');
      expect(response.body.data).to.have.property('inviteCode');
      expect(response.body.data.teamName).to.equal(teamData.teamName);
      
      // 验证可以获取创建的记录
      const teamId = response.body.data.id;
      const getResponse = await request(app)
        .get(`/api/registration/${teamId}`)
        .expect(200);
      
      expect(getResponse.body.success).to.be.true;
      expect(getResponse.body.data.teamName).to.equal(teamData.teamName);
      expect(getResponse.body.data.leader.name).to.equal(teamData.name);
      expect(getResponse.body.data.leader.phone).to.equal(teamData.phone);
    });
    
    it('should return error for duplicate phone number', async () => {
      const teamData = {
        name: '重复电话领队',
        phone: '13700000001',
        teamName: '重复测试团队'
      };
      
      // 第一次创建应该成功
      await request(app)
        .post('/api/registration/leader')
        .send(teamData)
        .expect(201);
      
      // 第二次使用相同电话号码应该失败
      const response = await request(app)
        .post('/api/registration/leader')
        .send(teamData)
        .expect(400);
      
      expect(response.body.success).to.be.false;
      expect(response.body.message).to.include('手机号已被注册');
    });
  });
  
  // 其他API测试...
});
```

## 测试覆盖率分析

为确保测试质量，定期运行覆盖率报告：

```bash
npm test -- --coverage
```

覆盖率目标：

- **语句覆盖率**：>80%
- **分支覆盖率**：>70%
- **函数覆盖率**：>80%
- **行覆盖率**：>80%

## 持续集成

在CI环境中自动运行测试：

```yaml
# .github/workflows/test.yml
name: Test

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v2
    
    - name: Use Node.js
      uses: actions/setup-node@v2
      with:
        node-version: '14.x'
        
    - name: Install dependencies
      run: npm ci
      
    - name: Run linting
      run: npm run lint
      
    - name: Run tests with coverage
      run: npm test -- --coverage
      
    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v2
```

## 注意事项

1. **模拟容器**：测试时替换容器，而不是个别依赖
2. **测试隔离**：每个测试应独立运行，不依赖其他测试
3. **边界条件**：测试正常路径和错误路径
4. **避免副作用**：避免测试对外部系统的依赖
5. **合理使用存根**：使用存根模拟外部服务和API 